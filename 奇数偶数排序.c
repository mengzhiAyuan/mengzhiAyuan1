#include<stdio.h> 
#include<stdlib.h>
#define maxsize 100
typedef struct{
	int r[maxsize];
	int length;
}SqList;

void Sort(SqList &L){
	int i,flag1,flag2,temp;
	flag1=1;flag2=0;int k=1;
	while(1){
		flag2=0;
		for(i=k;i<L.length-1;i+=2){
			if(L.r[i]>L.r[i+1]){
				temp=L.r[i];L.r[i]=L.r[i+1];L.r[i+1]=temp;
				flag2=1;
			}
		}
		if(flag1==0&&flag2==0) return;
		else{
			flag1=flag2;
			k=k%2+1;
		}
	}
}

int main(){
	SqList L;
	int i;
	scanf("%d",&L.length);
	for(i=1;i<L.length;i++){
		scanf("%d",&L.r[i]);
	}

	Sort(L);
	for(i=1;i<L.length;i++){
		printf("%d ",L.r[i]);
	}
	return 0;
	
}/*这个算法原理是也是比较简单的，接下来就给大家分享一下我的做法。以下面这几个数据来模拟方便大家理解：

给定一组数据如下：1，3，5，2，8，6，4，7

第一趟排序，对所有奇数项扫描，如果比后一项大，交换：

[1，3]，[5，2]，[8，6]，[4，7]   =>  [1，3]，[2，5]，[6，8]，[4，7]

第二趟排序，对所有偶数项扫描，如果比后一项大，交换：

1，[3，2]，[5，6]，[8，4]，7  =>  1，[2，3]，[5，6]，[4，8]，7

第三趟排序，对所有奇数项扫描，如果比后一项大，交换：

[1，2]，[3，5]，[6，4]，[8，7]   =>  [1，2]，[3，5]，[4，6]，[7，8]

第四趟排序，对所有偶数项扫描，如果比后一项大，交换：

1，[2，3]，[5，4]，[6，7]，8  =>  1，[2，3]，[4，5]，[6，7]，8 

通过这个分析，我想大家对这个；排序过程应该有比较深刻的了解了，我们会注意到两个问题：

1，一串数据可能有奇数个，可能有偶数个，怎么保证它不访问最后一个，导致出错呢？

答：我们可以通过设置循范围，当循环变量到总个数-1时，停止循环。

2，我们人眼能分辨到第四趟停止，计算机怎么实现呢？

答：我们设置两个中间变量m，n来控制，如果奇排序过程中有元素交换，m为1，否则为0；如果偶排序过程中有元素交换，n为1，否则为0。当mn同时为0时，说明奇偶都没有交换，这个时候说明数据有序*/
